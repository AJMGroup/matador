#!/usr/bin/env python
# coding: utf-8
""" This file calls all matador functionality,
parses user inputs and implements the stats submodule.
"""

from __future__ import print_function
# matador modules
from matador.query import DBQuery
from matador.hull import QueryConvexHull
from matador.utils.print_utils import print_failure, print_warning, print_notify
from matador.utils.cursor_utils import display_results
from matador.version import __version__
# import external libraries
import pymongo as pm
# import standard library
import argparse
from sys import argv
from os import uname
from os.path import isfile


class Matador(object):
    """ Class that implements the interface
    to MongoDB structure repository.
    """
    def __init__(self, *args, **kwargs):
        """ Initialise the query with command line
        arguments and return results.
        """
        # read args
        self.kwargs = kwargs
        self.args = vars(args[0])
        self.argstr = kwargs.get('argstr')

        # connect to MonoDB structure repository
        local = uname()[1]
        if local == 'cluster2':
            remote = 'node1'
        else:
            remote = None
        self.client = pm.MongoClient(remote)
        self.db = self.client.crystals

        # choose desired collections
        self.collections = dict()
        if self.args['subcmd'] not in ['import', 'rebuild']:
            if self.args['db'] is not None:
                for database in self.args['db']:
                    if database == 'all':
                        self.collections = dict()
                        self.collections['ajm'] = self.db['repo']
                        self.collections['oqmd'] = self.db['oqmd']
                    elif database == 'ajm':
                        database = 'repo'
                        self.collections['ajm'] = self.db['repo']
                    else:
                        self.collections[database] = self.db[database]
            else:
                self.collections['repo'] = self.db['repo']

        # print last spatula report
        self.report = self.client.crystals.spatula

        if (self.args.get('cell') or self.args.get('res') or self.args.get('pdb') or
                self.args.get('markdown') or self.args.get('latex') or self.args.get('param')):
            self.export = True
        else:
            self.export = False

        if self.args['subcmd'] == 'stats':
            self.stats()

        if self.args['subcmd'] in ['import', 'rebuild']:
            from matador.spatula import Spatula
            self.importer = Spatula(self.args)

        if self.args['subcmd'] == 'query':
            self.query = DBQuery(self.client, self.collections, **self.args)
            self.cursor = self.query.cursor

        if self.args['subcmd'] in ['swaps', 'polish']:
            from matador.polish import Polisher
            self.query = DBQuery(self.client, self.collections, **self.args)
            if self.args.get('hull_cutoff') is not None:
                self.hull = QueryConvexHull(self.query, **self.args)
                self.polisher = Polisher(self.hull.hull_cursor, self.args)
            else:
                self.polisher = Polisher(self.query.cursor, self.args)
            self.cursor = self.polisher.cursor

        if self.args['subcmd'] == 'refine':
            from matador.refine import Refiner
            self.query = DBQuery(self.client, self.collections, **self.args)
            if self.args.get('hull_cutoff') is not None:
                self.hull = QueryConvexHull(self.query, **self.args)
                self.refiner = Refiner(self.hull.cursor, self.query.repo, **self.args)
            else:
                self.refiner = Refiner(self.query.cursor, self.query.repo, **self.args)

        if self.args['subcmd'] == 'pdffit':
            self.query = DBQuery(self.client, self.collections, **self.args)
            self.cursor = list(self.query.cursor)
            if self.args.get('hull_cutoff') is not None:
                self.hull = QueryConvexHull(self.query, **self.args)
                self.cursor = self.hull.hull_cursor
                self.top = len(self.cursor)
            if self.args.get('top') is not None:
                self.top = self.args.get('top')
            if len(self.cursor[:self.top]) > 0:
                print_notify('Performing PDF fit for ' +
                             str(len(self.cursor[:self.top])) +
                             ' structures.')
                from matador.pdffit import PDFFitter
                self.pdffit = PDFFitter(self.cursor[:self.top], **self.args)
                try:
                    self.pdffit.spawn()
                except(KeyboardInterrupt, SystemExit):
                    exit('Exiting top-level...')
            else:
                exit('No structure match query.')

        if self.args['subcmd'] == 'hull' or self.args['subcmd'] == 'voltage':
            self.query = DBQuery(self.client, self.collections, **self.args)
            self.hull = QueryConvexHull(self.query, **self.args)
            self.cursor = self.hull.hull_cursor

        if self.args.get('uniq'):
            from matador.similarity.similarity import get_uniq_cursor
            print_notify('Filtering for unique structures...')
            if self.args.get('top') is not None:
                unique_set, _, _, _ = get_uniq_cursor(self.cursor[:self.args.get('top')],
                                                      debug=self.args.get('debug'), projected=True, sim_tol=self.args.get('uniq'))
                print('Filtered {} down to {}'.format(min(len(self.cursor),
                                                      self.args.get('top')),
                                                      len(unique_set)))
            else:
                unique_set, _, _, _ = get_uniq_cursor(self.cursor, debug=self.args.get('debug'), sim_tol=self.args.get('uniq'), projected=True)
                print('Filtered {} down to {}'.format(len(self.cursor),
                                                      len(unique_set)))
            self.cursor = [self.cursor[ind] for ind in unique_set]
            display_results(self.cursor, hull=None if self.args.get('subcmd') != 'hull' else True, args=self.args)

        # perform any extra filtration
        if self.args.get('filter'):
            from matador.utils.cursor_utils import filter_cursor
            self.cursor = filter_cursor(self.cursor,
                                        self.args.get('filter'),
                                        self.args.get('values'))

        if self.export and len(self.cursor) > 0:
            from matador.export import query2files
            query2files(self.cursor, self.args, argstr=self.argstr)

        if self.args.get('view'):
            from matador.viz import viz
            if self.args.get('top') is None:
                self.top = len(self.cursor)
            else:
                self.top = self.args.get('top')
            if len(self.cursor[:self.top]) > 10:
                from time import sleep
                print_warning('WARNING: opening {} files with ase-gui...'.format(len(self.cursor)))
                print_warning('Please kill script within 3 seconds if undesired...')
                sleep(3)
            if len(self.cursor[:self.top]) > 20:
                print_failure('You will literally be opening that many windows, ' +
                              'I\'ll give you another 5 seconds to reconsider...')

                sleep(5)
                print_notify('It\'s your funeral...')
                sleep(1)
            for doc in self.cursor[:self.top]:
                viz(doc)

        self.client.close()

    def print_report(self):
        """ Print spatula report on current database. """
        try:
            report = self.report.find_one()
            print('Database last modified on', report['last_modified'], 'with matador',
                  report['version'] + '.')
        except:
            print_warning('Failed to print database report: spatula is probably running!')

    def stats(self):
        """ Print some useful stats about the database. """
        if self.args.get('list'):
            print_notify(str(len(self.db.collection_names())) +
                         ' collections found in database:\n')
            for name in self.db.collection_names():
                collstats = self.db.command('collstats', name)
                print("\t{:<15}\t\t{:>10d}".format(name, collstats['count']))
            print('\n')
        else:
            comp_list = dict()
            overall_stats_dict = dict()
            overall_stats_dict['count'] = 0
            overall_stats_dict['avgObjSize'] = 0
            overall_stats_dict['storageSize'] = 0
            for collection in self.collections:
                db_stats_dict = self.db.command('collstats', collection)
                overall_stats_dict['count'] += db_stats_dict['count']
                overall_stats_dict['avgObjSize'] += db_stats_dict['avgObjSize']
                overall_stats_dict['storageSize'] += db_stats_dict['storageSize']
            print('The collection(s) queried in', self.db.name, 'contain',
                  overall_stats_dict['count'], 'structures at',
                  "{:.1f}".format(overall_stats_dict['avgObjSize']/(1024*len(self.collections))),
                  'kB each, totalling',
                  "{:.1f}".format(overall_stats_dict['storageSize']/(1024**2)),
                  'MB when padding is included.')
            for collname in self.collections:
                cursor = self.collections[collname].find()
                for doc in cursor:
                    temp = ''
                    for ind, elem in enumerate(doc['stoichiometry']):
                        temp += str(elem[0])
                        if ind != len(doc['stoichiometry']) - 1:
                            temp += '+'
                    if temp not in comp_list:
                        comp_list[temp] = 0
                    comp_list[temp] += 1
            keys = list(comp_list.keys())
            vals = list(comp_list.values())
            comp_list = list(zip(keys, vals))
            comp_list.sort(key=lambda t: t[1], reverse=True)
            small_count = 0
            first_ind = 1000
            cutoff = 100
            for ind, comp in enumerate(comp_list):
                if comp[1] < cutoff:
                    if ind < first_ind:
                        first_ind = ind
                    small_count += comp[1]
            comp_list = comp_list[:first_ind]
            comp_list.append(['others < ' + str(cutoff), small_count])
            comp_list.sort(key=lambda t: t[1], reverse=True)
            try:
                from ascii_graph import Pyasciigraph
                from ascii_graph.colors import Gre, Blu, Red
                from ascii_graph.colordata import hcolor
            except:
                print_failure('Pyascii graph missing; not printing detailed stats.')
                exit()
            graph = Pyasciigraph(line_length=80, multivalue=False)
            thresholds = {int(overall_stats_dict['count'] / 40): Gre,
                          int(overall_stats_dict['count'] / 10): Blu,
                          int(overall_stats_dict['count'] / 4): Red}
            data = hcolor(comp_list, thresholds)
            for line in graph.graph(label=None, data=data):
                print(line)
            print('\n')

    def temp_collection(self, cursor):
        """ Create temporary collection
        for successive filtering.
        """
        # check temp doesn't already exist; drop if it does
        try:
            self.client.crystals.temp.drop()
        except:
            pass
        self.temp = self.client.crystals.temp
        if len(cursor) != 0:
            self.temp.insert(cursor)
        else:
            self.temp.drop()
            print_failure('No structures found.')
            exit()
        return self.temp


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        prog='matador',
        description='MATerial and Atomic Database Of Refined structures.',
        epilog='Written and maintained by Matthew Evans (me388@cam.ac.uk) 2016-2017, version ' +
               __version__.strip() + '.')
    parser.add_argument('--version', action='version', version='matador version ' +
                        __version__ + '.')

    # define subparsers for subcommands
    subparsers = parser.add_subparsers(title='subcommands',
                                       description='valid sub-commands',
                                       dest='subcmd')

    # define parent parser for global arguments
    global_flags = argparse.ArgumentParser(add_help=False)

    # common arguments to all subcommands
    global_flags.add_argument('--db',
                              help='choose which databases to query',
                              nargs='+')
    global_flags.add_argument('--debug', action='store_true',
                              help='enable debug printing throughout code.')
    global_flags.add_argument('--devel', action='store_true',
                              help='test devel code.')
    global_flags.add_argument('--profile', action='store_true',
                              help='run code profiler.')

    # define all other flags by group
    structure_flags = argparse.ArgumentParser(add_help=False)
    structure_flags.add_argument('-c', '--composition', type=str, nargs='+',
                                 help='find all structures containing exclusively the given elements, \
                                       e.g. LiSi. Macros defined for groups [I]-[VII], [Tran] \
                                       [Lan] and [Act], used with square brackets.')
    structure_flags.add_argument('-int', '--intersection', action='store_true',
                                 help='query the intersection of compositions instead of the union \
                                       e.g. -c LiSnS -int queries Li, Sn, S, LiSn, LiS & LiSnS.')
    structure_flags.add_argument('-n', '--num_species', type=int, nargs='+',
                                 help='find all structures containing a certain \
                                       number of species.')
    structure_flags.add_argument('-f', '--formula', type=str, nargs='+',
                                 help='query a particular chemical formula, e.g. GeTeSi3')
    structure_flags.add_argument('-i', '--id', type=str, nargs='+', help='specify a particular structure by its text_id')
    structure_flags.add_argument('-ac', '--calc_match', action='store_true',
                                 help='display calculations of the same accuracy as specified id')
    structure_flags.add_argument('-kpttol', '--kpoint-tolerance', type=float,
                                 help='kpoint tolerance for calculation matches (DEFAULT: +/- 0.01 1/A')
    structure_flags.add_argument('-z', '--num_fu', type=int,
                                 help='query a calculations with more than n formula units')
    structure_flags.add_argument('-sg', '--space_group',
                                 help='query a particular space group')
    structure_flags.add_argument('-u', '--uniq', type=float, nargs='?', const=0.05,
                                 help='float, return only unique structures (filtered by PDF overlap), to this tolerance (DEFAULT: 0.05)')
    structure_flags.add_argument('-p', '--pressure', type=float,
                                 help='specify an isotropic external pressure to search for \
                                       , e.g. 10 (GPa)')
    structure_flags.add_argument('-pf', '--partial-formula', action='store_true',
                                 help='stoichiometry/composition queries will include other \
                                       unspecified species, e.g. -pf search for Li will query \
                                       any structure containing Li, not just pure Li.')
    structure_flags.add_argument('--tags', nargs='+', type=str,
                                 help=('search for manual tags'))
    structure_flags.add_argument('--doi', type=str,
                                 help=('search for DOI in format xxxx/xxxx'))
    structure_flags.add_argument('-icsd', '--icsd', type=int, const=0, nargs='?',
                                 help=('search for an ICSD CollCode'))
    structure_flags.add_argument('-ss', '--src_str', type=str,
                                 help=('search for a string inside the structure sources'))
    structure_flags.add_argument('-encap', '--encapsulated', action='store_true',
                                 help='query only structures encapsulated in a carbon nanotube.')
    structure_flags.add_argument('-cntr', '--cnt_radius', type=float,
                                 help='specify the radius of the encapsulating nanotube \
                                       to within 0.01 A')
    structure_flags.add_argument('-cntv', '--cnt_vector', type=int, nargs='+',
                                 help='specify the chiral vector of the encapsulating nanotube')
    structure_flags.add_argument('-ecut', '--cutoff', type=float, nargs='+',
                                 help='specify the minimum and optionally maximum planewave cutoff.')
    structure_flags.add_argument('--sedc', type=str,
                                 help='specify the dispersion correction scheme, e.g. TS or null.')
    structure_flags.add_argument('-xc', '--xc_functional', type=str,
                                 help='specify a particular xc-functional to query (case-insensitive).')
    structure_flags.add_argument('-kpts', '--mp_spacing', type=float,
                                 help='specify an MP grid spacing in 2pi/A units, e.g. 0.05, will \
                                 return all values structures with value within --kpt_tol of that specified')
    structure_flags.add_argument('--spin', type=str,
                                 help='specifiy whether to query non-spin-polarized (0) calcs or \
                                 spin polarized calcs (!=1).')
    structure_flags.add_argument('--loose', action='store_true',
                                 help='loosely matches with calc_match, i.e. only matches \
                                       pspot and xc_functional')
    structure_flags.add_argument('--ignore_warnings', action='store_true',
                                 help='includes possibly bad structures')
    structure_flags.add_argument('--filter', type=str,
                                 help='specify a simple float field to filter. Requires --values')
    structure_flags.add_argument('--values', nargs='+', type=float,
                                 help='specify the minimum floats, or [min, max] values of field')

    material_flags = argparse.ArgumentParser(add_help=False)
    material_flags.add_argument('-hc', '--hull_cutoff', type=float,
                                help='return only structures within a certain distance from hull \
                                      in eV/atom')
    material_flags.add_argument('-hT', '--hull_temp', type=float,
                                help='return only structures within a certain distance from hull \
                                      in K')
    material_flags.add_argument('--biggest', action='store_true',
                                help='use the largest subset of structures to create a hull')
    material_flags.add_argument('--volume', action='store_true',
                                help='plot a volume curve from convex hull\
                                      (currently limited to binaries)')
    material_flags.add_argument('--chempots', type=float, nargs='+',
                                help='manually specify chem pots as enthalpy per atom for \
                                      a rough hull.')

    plot_flags = argparse.ArgumentParser(add_help=False)
    plot_flags.add_argument('--pdf', action='store_true',
                            help='save pdf rather than showing plot in X')
    plot_flags.add_argument('--png', action='store_true',
                            help='save png rather than showing plot in X')
    plot_flags.add_argument('--csv', action='store_true',
                            help='save plotting data to separate csv files')
    plot_flags.add_argument('--labels', action='store_true',
                            help='label hull plots')
    plot_flags.add_argument('--svg', action='store_true',
                            help='save svg rather than showing plot in X')
    plot_flags.add_argument('--subplot', action='store_true',
                            help='plot combined hull and voltage graph')
    plot_flags.add_argument('--bokeh', action='store_true',
                            help='plot using bokeh')
    plot_flags.add_argument('--no_plot', action='store_true',
                            help='suppress plotting')
    plot_flags.add_argument('--capmap', action='store_true',
                            help='plot heat map of gravimetric capacity')
    plot_flags.add_argument('--sampmap', action='store_true',
                            help='plot heat map of concentration sampling')
    plot_flags.add_argument('--efmap', action='store_true',
                            help='plot heat map of formation energy')
    plot_flags.add_argument('--pathways', action='store_true',
                            help='plot line from stable B_x C_y to pure A in ABC ternary.')
    plot_flags.add_argument('--expt', type=str,
                            help='enter experimental voltage curve .csv file for plotting.')
    plot_flags.add_argument('--expt_label', type=str,
                            help='label for experimental data on voltage curve.')

    spatula_flags = argparse.ArgumentParser(add_help=False)
    spatula_flags.add_argument('-d', '--dryrun', action='store_true',
                               help='run the importer without connecting to the database')
    spatula_flags.add_argument('-v', '--verbosity', action='count',
                               help='enable verbose output')
    spatula_flags.add_argument('-t', '--tags', nargs='+', type=str,
                               help='set user tags, e.g. nanotube, project name')
    spatula_flags.add_argument('-s', '--scan', action='store_true',
                               help='only scan the database for new structures, do not dictify')

    collection_flags = argparse.ArgumentParser(add_help=False)
    collection_flags.add_argument('--to', type=str,
                                  help='the text_id of a structure with the desired parameters')
    collection_flags.add_argument('--with', type=str,
                                  help=('the seedname (must be within pwd) of cell and param ' +
                                        'files to use for polishing/swaps'))
    collection_flags.add_argument('--prefix', type=str,
                                  help='add a prefix to all file names to write out (auto-appended \
                                        with an underscore')

    query_flags = argparse.ArgumentParser(add_help=False)
    query_flags.add_argument('-s', '--summary', action='store_true',
                             help='show only the ground state for each stoichiometry.')
    query_flags.add_argument('-t', '--top', type=int,
                             help='number of structures to show/write (DEFAULT: 10)')
    query_flags.add_argument('-dE', '--delta_E', type=float,
                             help='maximum distance from ground state structure to show/write in eV/atom')
    query_flags.add_argument('-d', '--details', action='store_true',
                             help='show as much detail about calculation as possible')
    query_flags.add_argument('-pa', '--per_atom', action='store_true',
                             help='show quantities per atom not per fu.')
    query_flags.add_argument('--source', action='store_true',
                             help='print filenames from which structures were wrangled')
    query_flags.add_argument('-v', '--view', action='store_true',
                             help='quickly view a structure/structures with ase-gui')
    query_flags.add_argument('--cell', action='store_true',
                             help='export query to .cell files in folder name from query string')
    query_flags.add_argument('--param', action='store_true',
                             help='export query to .param files in folder name from query string')
    query_flags.add_argument('--res', action='store_true',
                             help='export query to .res files in folder name from query string')
    query_flags.add_argument('--pdb', action='store_true',
                             help='export query to .pdb files in folder name from query string')
    query_flags.add_argument('--markdown', action='store_true',
                             help='export query summary to a markdown file')
    query_flags.add_argument('--latex', action='store_true',
                             help='export query summary to a LaTeX table')

    swap_flags = argparse.ArgumentParser(add_help=False)
    swap_flags.add_argument('-sw', '--swap', type=str, nargs='+',
                            help='swap all atoms in structures from a query from the first n-1 \
                                  species to the nth, e.g. -sw NAs will swap all N to As, \
                                  -sw NAs:LiNa will swap all N to As, and all Li to Na, and \
                                  -sw [V]As:[Li,K,Rb]Na will swap all group V elements to As \
                                  and all of Li, K and Rb to Na.')

    pdffit_flags = argparse.ArgumentParser(add_help=False)
    pdffit_flags.add_argument('-file', '--file', type=str,
                              help='experimental input file to fit structures to.')
    pdffit_flags.add_argument('-min', '--xmin', type=float,
                              help='minimum value to compute the PDF (DEFAULT: 1 Angstrom)')
    pdffit_flags.add_argument('-max', '--xmax', type=float,
                              help='maximum value to compute the PDF (DEFAULT: 50 Angstrom')
    pdffit_flags.add_argument('-dx', '--dx', type=float,
                              help='spacing to compute PDF at')
    pdffit_flags.add_argument('-2', '--two_phase', type=float,
                              help='fit two phases to experimental PDF')
    pdffit_flags.add_argument('-np', '--num_processes', type=int,
                              help='number of concurrent fits to perform.')

    refine_flags = argparse.ArgumentParser(add_help=False)
    refine_flags.add_argument('-task', '--task', type=str,
                              help='refine subtask to perform: options are spg or sub')
    refine_flags.add_argument('-mode', '--mode', type=str,
                              help='mode of refinement: options are display, set and overwrite')
    refine_flags.add_argument('-symprec', '--symprec', type=float,
                              help='spglib symmetry precision for refinement')
    refine_flags.add_argument('--new_tag', type=str,
                              help='new tag to add to structures in query')
    refine_flags.add_argument('--new_doi', type=str,
                              help='new doi to add to structures in query')

    stats_flags = argparse.ArgumentParser(add_help=False)

    # define subcommand parsers and their arguments
    stat_parser = subparsers.add_parser('stats',
                                        help='print some stats about the database.',
                                        parents=[global_flags, stats_flags])
    query_parser = subparsers.add_parser('query',
                                         help='query and extract structures from the database',
                                         parents=[global_flags, query_flags, structure_flags])
    import_parser = subparsers.add_parser('import',
                                          help='import new structures in folder into database',
                                          parents=[global_flags, spatula_flags])
    rebuild_parser = subparsers.add_parser('rebuild',
                                           help='rebuild whole database.',
                                           parents=[spatula_flags])
    pdffit_parser = subparsers.add_parser('pdffit',
                                          help='provide experimental .gr file and fit to calculated \
                                                PDF of structures in query',
                                          parents=[global_flags, query_flags, material_flags,
                                                   structure_flags, pdffit_flags])
    hull_parser = subparsers.add_parser('hull',
                                        help='create a convex hull from query results \
                                        (currently limited to binaries)',
                                        parents=[global_flags, structure_flags,
                                                 material_flags, plot_flags, query_flags])
    voltage_parser = subparsers.add_parser('voltage',
                                           help='plot a voltage curve from query results \
                                           (currently limited to binaries)',
                                           parents=[global_flags, structure_flags,
                                                    material_flags, plot_flags, query_flags])
    swaps_parser = subparsers.add_parser('swaps',
                                         help='perform atomic swaps on query results',
                                         parents=[global_flags, collection_flags, query_flags,
                                                  structure_flags, material_flags, swap_flags])
    polish_parser = subparsers.add_parser('polish',
                                          help='re-relax a series of structures with \
                                          new parameters.',
                                          parents=[global_flags, collection_flags,
                                                   structure_flags, material_flags,
                                                   query_flags])
    refine_parser = subparsers.add_parser('refine',
                                          help='refine database structures',
                                          parents=[global_flags, query_flags, structure_flags,
                                                   refine_flags, material_flags])

    args = parser.parse_args()

    # check for inconsistent argument combinations
    if vars(args).get('include_oqmd'):
        print_failure('--include_oqmd is currently disabled, please try again soon...')
        exit()
    if vars(args).get('intersection') and vars(args).get('composition') is None:
        print_failure('--intersection requires --composition.')
        exit()
    if vars(args).get('filter') and vars(args).get('values') is None:
        print_failure('--filter requires --values.')
        exit()
    if vars(args).get('values') and vars(args).get('filter') is None:
        print_warning('Ignoring redundant supplied values...')
    if vars(args).get('subcmd') == 'hull' and vars(args).get('composition') is None:
        print_failure('hull requires --composition')
        exit()
    if vars(args).get('subcmd') == 'pdffit':
        if vars(args).get('file') is None:
            print_failure('pdffit requires specified --file, exiting...')
            exit()
        if not isfile(vars(args).get('file')):
            print_failure('specified --file does not exist, exiting...')
            exit()
    if vars(args).get('hull_cutoff') and vars(args).get('hull_temp'):
        print_failure('hull_cutoff and hull_temp both specified, exiting...')
        exit()
    if vars(args).get('calc_match') and vars(args).get('id') is None:
        print_failure('calc_match requires specification of a text_id with -i, exiting...')
        exit()
    if vars(args).get('profile'):
        import cProfile
        import pstats
        from sys import version_info
        pr = cProfile.Profile()
        pr.enable()
    matador = Matador(args, argstr=argv[1:])
    if vars(args).get('profile'):
        pr.disable()
        with open('matador-' +
                  str(version_info.major) + '.' +
                  str(version_info.minor) + '.' +
                  str(version_info.micro) +
                  '.cProfile', 'w') as s:
            sortby = 'cumulative'
            ps = pstats.Stats(pr, stream=s).sort_stats(sortby)
            ps.print_stats()
